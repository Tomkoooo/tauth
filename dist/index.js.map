{"version":3,"sources":["../src/index.ts","../src/db/mongodb.ts","../src/utils/generateToken.ts","../src/utils/options.ts","../src/utils/otp.ts","../src/types/user.ts","../src/middlewere/appRouterMidlewere.ts","../src/utils/getClientIp.ts","../src/auth/getUser.ts","../src/middlewere/pagesRouterMidllewere.ts","../src/middlewere/expressMiddlewere.ts","../src/hooks/userHook.tsx","../src/emailService/mailer.ts","../src/emailService/sendVerifcationEmail.ts","../src/auth/register.ts","../src/auth/login.ts","../src/auth/verification.ts"],"sourcesContent":["// index.ts\n\n//db\n\n//MongoDB connection\nexport {connectToDatabase} from './db/mongodb';\n\n//utils\n\n//generateToken(userId: string, clientIp: string)\nexport {generateToken} from './utils/generateToken';\n//validateToken(token:string, clientIp?: string)\nexport {validateToken} from './utils/generateToken';\n\n//emailOptions() -> {html: string, subject: string} (auth.options.json)\nexport {emailOptions} from './utils/options';\n//authOptions() -> {authMethod: string, verificationRequired: boolean} (auth.options.json)\nexport {authOptions} from './utils/options';\n//userSchemaOptions() -> type User (auth.schema.json)\nexport {userSchemaOptions} from './utils/options';\n//routesOptions() -> {routes: {key: {type: string, credentials?: string, redirectTo?: string}}} (auth.options.json)\nexport {routesOptions} from './utils/options';\n\n//generateVerificationCode(userId: string, verificationMethod: string)\nexport {generateVerificationCode} from './utils/otp';\n\n//types\n\n//User type\nexport {User} from './types/user';\n\n//middlewere\n\n//appRouterMiddlewere()\nexport {appRouterMiddleware} from './middlewere/appRouterMidlewere';\n//pagesRouterMiddlewere()\nexport {pagesRouterMiddlewere} from './middlewere/pagesRouterMidllewere';\n//expressJS middlewere\nexport {expressMiddlewere} from './middlewere/expressMiddlewere';\n\n//hooks\n\n//userHook\nexport {UserProvider, useUser} from './hooks/userHook';\n\n//emailService\n\n//sendMail(to. string, subject: string, html?: string, text?: string)\nexport {sendMail} from './emailService/mailer';\n//sendVerificationEmail(to: string, code: number)\nexport {sendVerificationEmail} from './emailService/sendVerifcationEmail';\n\n//auth\n\n//registerUser(email: string, password: string)\nexport {registerUser} from './auth/register';\n//loginUser(identifier: string, password: string)\nexport {loginUser} from './auth/login';\n//getUser(token: string, ip?: string)\nexport {getUser} from './auth/getUser';\n\n//verification\n\n//verifyEmail(token: string, verificationCode: number)\nexport {verifyEmail} from './auth/verification';\n//resetPassword(email: string, resetCode: number, newPassword: string)\nexport {resetPassword} from './auth/verification';\n//requestPasswordReset(email: string)\nexport {requestPasswordReset} from './auth/verification';\n//resendVerificationEmail(email: string)\nexport {resendVerificationEmail} from './auth/verification';","// src/db/mongodb.ts\nimport { MongoClient, Db } from 'mongodb';\n\nlet client: MongoClient | null = null;\n\nexport const connectToDatabase = async (): Promise<Db> => {\n  const mongoUri = process.env.MONGO_URI;\n  const dbName = process.env.MONGO_DB_NAME;\n\n  if (!mongoUri) {\n    throw new Error(\"MONGO_URI env variable is missing.\");\n  }\n\n  if (!dbName) {\n    throw new Error(\"MONGO_DB_NAME env variable is missing.\");\n  }\n\n  if (!client) {\n    client = new MongoClient(mongoUri);\n    await client.connect();\n  }\n\n  return client.db(dbName);\n};","import jwt from 'jsonwebtoken';\nimport crypto from 'crypto';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your_jwt_secret';\nconst EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\n\nexport function generateToken(userId: string, clientIp: string) {\n    // Hash the userId, JWT_SECRET, and clientIp to create a unique token hash\n    const hashedUserId = hash(userId + JWT_SECRET);\n    const hashedClientIp = hash(clientIp + JWT_SECRET);\n\n    // Generate a JWT with the combined hash of userId and clientIp\n    const token = jwt.sign(\n        { hash: hash(userId + clientIp + JWT_SECRET) },\n        JWT_SECRET,\n        { expiresIn: EXPIRES_IN }\n    );\n\n    // Return the JWT token, hashedUserId, and original userId hash for verification\n    return {\n        token,\n        hashedUserId,\n        hashedClientIp\n    };\n}\n\n// Helper function to hash values with SHA-256\nfunction hash(value: string): string {\n    return crypto.createHash('sha256').update(value).digest('hex');\n}\n\n// Example function to validate the token on the server side\nexport function validateToken(token: string, userId: string, clientIp?: string | Promise<string | null>): boolean {\n    try {\n        if (!clientIp) return false;\n        // Decode the JWT\n        const decoded = jwt.verify(token, JWT_SECRET) as { hash: string };\n        \n        // Recreate the hash using the same approach\n        const expectedHash = hash(userId + clientIp + JWT_SECRET);\n        \n        // Compare the recreated hash with the one from the token\n        return decoded.hash === expectedHash;\n    } catch (err) {\n        console.error(\"Token validation error:\", err);\n        return false;\n    }\n}\n","// /src/utils/options.ts\n'use server'\nimport fs from 'fs';\nimport path from 'path';\n\ninterface emailTemplate{\n    html: string\n    subject: string\n}\n\ninterface Routes {\n    routes: {\n        [key: string]: {\n            type: string\n            credentials?: string\n            redirectTo?: string\n        }\n    }\n}\n\nexport const emailOptions = () => {\n    const defaultEmailTemplate = {\n        html: 'Please use the following code to verify your email: <strong>{{code}}</strong>',\n        subject: 'Email verification code'\n    }\n    const optionsPath = path.resolve(process.cwd(), 'auth.options.json');\n    if (!fs.existsSync(optionsPath)) {\n        return defaultEmailTemplate as emailTemplate;\n    }\n    const options = fs.readFileSync(optionsPath, 'utf-8');\n    //extract the emailTemplate object from the file\n    return JSON.parse(options).emailTemplate as emailTemplate;\n}\nexport const userSchemaOptions = () => {\n    const defaultUserSchema = {\n        name: '',\n        email: '',\n        password: '',\n        role: 'user',\n        verified: false,\n        codes: {\n          reset: null,\n          token: null,\n          verification: null\n        }\n      };\n    const optionsPath = path.resolve(process.cwd(), 'auth.schema.json');\n    if (!fs.existsSync(optionsPath)) {\n        return defaultUserSchema;\n    }\n    const options = fs.readFileSync(optionsPath, 'utf-8');\n    //extract the userSchema object from the file and mix it with the defaultUserSchema\n    return {...defaultUserSchema, ...JSON.parse(options).userSchema};\n}\n\nexport const authOptions = () => {\n    const defaultOptions = {\n        verifcationRequired: false,\n        authMethod: 'both',\n    }\n    const optionsPath = path.resolve(process.cwd(), 'auth.options.json');\n    if (!fs.existsSync(optionsPath)) {\n        return defaultOptions;\n    }\n    const options = fs.readFileSync(optionsPath, 'utf-8');\n    //extract the authOptions object from the file\n    return JSON.parse(options).authOptions;\n}\n\nexport const routesOptions = () => {\n    const routeOptionsPath = path.resolve(process.cwd(), 'auth.routes.json');\n    if (!fs.existsSync(routeOptionsPath)) {\n        return null;\n    }\n    const routeOptions = fs.readFileSync(routeOptionsPath, 'utf-8');\n    //extract the routes object from the file\n    return JSON.parse(routeOptions) as Routes;\n}","// src/utils/verification.ts\n'use server'\nimport { connectToDatabase } from \"../db/mongodb\"\nimport { ObjectId } from \"mongodb\";\n\nexport const generateVerificationCode = async (userId: string, verificationMethod: string) => {\n    const code = Math.floor(100000 + Math.random() * 900000) //returns a random 6 digit number;\n    const db = await connectToDatabase();\n    const users = db.collection(\"users\");\n\n    const user = await users.findOne({ _id: new ObjectId(userId) });\n    if (!user) {\n        throw new Error(\"User not found.\");\n    }\n\n    await users.updateOne(\n        { _id: new ObjectId(userId) },\n        {\n            $set: {\n                [`codes.${verificationMethod}`]: code\n            }\n        }\n    )\n\n    return code;\n}","// src/types/user.ts\n\n//export the default user type with the auth.schema.options\n\nimport { userSchemaOptions } from \"../utils/options\";\n\nconst User = userSchemaOptions();\n\nexport type User = ReturnType<typeof User>;","import { NextResponse, NextRequest } from 'next/server';\nimport { getUser } from '../auth/getUser';\nimport { routesOptions } from '../utils/options';\nimport { cookies } from 'next/headers';\n\nexport async function appRouterMiddleware(req: NextRequest) {\nconst ip = req.headers.get('x-real-ip') || req.headers.get('x-forwarded-for');\nconst { pathname } = req.nextUrl; // Get the current route path\nconst cookieToken = (await cookies()).get('token')?.value?.toString() || '';\nconst session = await getUser(cookieToken, ip);\nconst routes = routesOptions();\nlet routeConfig;\n\nif (routes) {\n    routeConfig = routes.routes[pathname];\n}\n\n  if (routeConfig) {\n    // Public route - no authentication required\n    if (routeConfig.type === 'public') {\n      return NextResponse.next();\n    }\n\n    // Private route - check credentials\n    if (routeConfig.type === 'private' && routeConfig.credentials && routeConfig.redirectTo) {\n      if (session.success) {\n        // Evaluate the credentials condition\n        const user = session.user; // Assuming session has user object\n        const condition = new Function('user', `return ${routeConfig.credentials}`);\n        if (condition(user)) {\n          return NextResponse.next();\n        } else {\n          return NextResponse.redirect(new URL(routeConfig.redirectTo, req.url));\n        }\n      } else {\n        // No session, redirect to login\n        return NextResponse.redirect(new URL(routeConfig.redirectTo, req.url));\n      }\n    }\n  }\n\n  // If route not found in the config, continue as normal\n  return NextResponse.next();\n}\n\n// Define matcher for Pages Router by adding specific paths based on routesOptions config\nexport const config = {\n    matcher: Object.keys(routesOptions()!.routes).map((path) => path.startsWith('/') ? path : `/${path}`),\n  };\n","// src/utils/getClientIp.ts\nexport async function getClientIp(): Promise<string | null> {\n    try {\n      const response = await fetch('https://api64.ipify.org?format=json');\n      if (!response.ok) throw new Error('Failed to fetch IP');\n      \n      const data = await response.json();\n      return data.ip;\n    } catch (error) {\n      console.error('Could not retrieve client IP:', error);\n      return null; // Fallback in case of error\n    }\n  }\n  ","// src/auth/getUser.ts\n'use server'\nimport { connectToDatabase } from \"../db/mongodb\";\nimport { getClientIp } from \"../utils/getClientIp\";\nimport jwt from \"jsonwebtoken\";\nimport { validateToken } from \"../utils/generateToken\";\n\nconst JWT_SECRET = process.env.JWT_SECRET || \"your_jwt_secret\";\n\nexport const getUser = async (token: string, ip?: string | null) => {\n    try {\n        const db = await connectToDatabase();\n        const users = db.collection(\"users\");\n\n        // Retrieve client IP, either provided directly or from another utility function\n        const clientIp = ip || getClientIp();\n        if (!clientIp) {\n            throw new Error(\"Could not get client IP.\");\n        }\n\n        // Decode the JWT to extract the userId\n        const decoded = jwt.verify(token, JWT_SECRET) as { userId: string };\n        const userId = decoded.userId;\n\n        // Use validateToken to verify that the token is valid for the userId and clientIp\n        const isValidToken = validateToken(token, userId, clientIp);\n        if (!isValidToken) {\n            throw new Error(\"Invalid token.\");\n        }\n\n        // If token is valid, query the user in the database by userId\n        const user = await users.findOne({ userId });\n        if (!user) {\n            throw new Error(\"User not found.\");\n        }\n\n        // Return user data if found\n        return {success: true, user};\n    } catch (error) {\n        console.error(\"Error fetching user:\", error);\n        throw new Error(\"Unable to authenticate user.\");\n    }\n};\n","import { NextResponse, NextRequest } from 'next/server';\nimport { getUser } from '../auth/getUser';\nimport { routesOptions } from '../utils/options';\n\n// Secret for JWT verification (customize as needed)\nconst secret = new TextEncoder().encode(process.env.JWT_SECRET || 'your-secret-key'); \n\nexport async function pagesRouterMiddlewere(req: NextRequest) {\n  const { pathname } = req.nextUrl;\n  \n  // Retrieve IP information\n  const forwarded = req.headers.get('x-forwarded-for');\n  const ip = forwarded ? forwarded.split(',')[0] : req.headers.get('x-real-ip') || req.nextUrl.hostname;\n  \n  // Retrieve token from cookies\n  const cookieToken = req.cookies.get('token')?.value || ''; \n  const routes = routesOptions();\n  const session = await getUser(cookieToken, ip);\n  \n  // Get route configuration for the current path\n  const routeConfig = routes?.routes?.[pathname];\n  \n  // Allow access if route is undefined in config (e.g., unlisted public route)\n  if (!routeConfig) return NextResponse.next();\n\n  // Public route logic\n  if (routeConfig.type === 'public') return NextResponse.next();\n\n  // Private route logic\n  if (routeConfig.type === 'private') {\n    if (!cookieToken) {\n      // Redirect to login if not authenticated\n      return NextResponse.redirect(new URL(routeConfig.redirectTo || '/login', req.url));\n    }\n\n    try {\n      // Verify and check user credentials if provided\n      if (routeConfig.credentials) {\n        const condition = new Function('user', `return ${routeConfig.credentials}`);\n        if (!session.success || !condition(session.user)) {\n          return NextResponse.redirect(new URL(routeConfig.redirectTo || '/login', req.url));\n        }\n      }\n      \n      // If session is valid and conditions are met, proceed\n      return NextResponse.next();\n    } catch (error) {\n      // Redirect to login if session verification fails\n      return NextResponse.redirect(new URL(routeConfig.redirectTo || '/login', req.url));\n    }\n  }\n\n  // Allow access if no specific config is set for route type\n  return NextResponse.next();\n}\n\n// Define matcher for Pages Router by adding specific paths based on routesOptions config\nexport const config = {\n  matcher: Object.keys(routesOptions()!.routes).map((path) => path.startsWith('/') ? path : `/${path}`),\n};\n","import { Request, Response, NextFunction, Express } from 'express';\nimport { getUser } from '../auth/getUser';\nimport { routesOptions } from '../utils/options';\n\nconst authMiddleware = async (req: Request, res: Response, next: NextFunction) => {\n  const routes = routesOptions();\n  const { originalUrl: pathname } = req; // Use original URL path\n  const cookieToken = req.cookies?.token || ''; // Get JWT token from cookies\n  const ip = req.headers['x-forwarded-for']?.toString().split(',')[0] || req.socket.remoteAddress; // Get client IP\n\n  const routeConfig = routes?.routes?.[pathname];\n\n  // Allow access if route is undefined in config (e.g., unlisted public route)\n  if (!routeConfig) return next();\n\n  // Public route logic - allow access without further checks\n  if (routeConfig.type === 'public') return next();\n\n  // For private routes, check token validity\n  if (routeConfig.type === 'private') {\n    if (!cookieToken) {\n      return res.redirect(routeConfig.redirectTo || '/login');\n    }\n\n    try {\n      // Retrieve session/user information\n      const session = await getUser(cookieToken, ip);\n\n      // Check user credentials if specified\n      if (routeConfig.credentials && session.success) {\n        const user = session.user;\n        const condition = new Function('user', `return ${routeConfig.credentials}`);\n        if (!condition(user)) {\n          return res.redirect(routeConfig.redirectTo || '/login');\n        }\n      }\n\n      return next(); // Pass through if authenticated and conditions are met\n    } catch (error) {\n      console.error('Token verification error:', error);\n      return res.redirect(routeConfig.redirectTo || '/login');\n    }\n  }\n\n  // Default to allowing access if no specific route configuration matches\n  return next();\n};\n\n// Apply middleware to specific routes dynamically based on config\nexport const expressMiddlewere = (app: Express) => {\n  const routes = routesOptions();\n  const protectedPaths = Object.keys(routes!.routes);\n\n  protectedPaths.forEach((path) => {\n    app.use(path, authMiddleware); // Apply middleware to each defined route\n  });\n};\n","// src/hooks/userHooktsx\n\n'use client'\n\nimport React, { createContext, useContext, useEffect, useState } from 'react';\nimport { User } from '../types/user'; // Assuming you have the User type defined\n\ninterface UserContextType {\n  user: User | null;\n  loading: boolean;\n  setUser: React.Dispatch<React.SetStateAction<User | null>>;\n  setLoading: React.Dispatch<React.SetStateAction<boolean>>;\n}\n\nconst UserContext = createContext<UserContextType | undefined>(undefined);\n\nexport const UserProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n\n  return (\n    <UserContext.Provider value={{ user, loading, setUser, setLoading }}>\n      {children}\n    </UserContext.Provider>\n  );\n};\n\nexport const useUser = (): UserContextType => {\n  const context = useContext(UserContext);\n  if (!context) {\n    throw new Error(\"useUser must be used within a UserProvider\");\n  }\n  return context;\n};","// src/emailService/mailer\n'use server'\n\nimport nodemailer from 'nodemailer';\n\nconst transporter = nodemailer.createTransport({\n  host: process.env.SMTP_HOST,\n  port: Number(process.env.SMTP_PORT),\n  secure: process.env.SMTP_SECURE === 'true',\n  auth: {\n    user: process.env.SMTP_USER,\n    pass: process.env.SMTP_PASS,\n  },\n});\n\nexport const sendMail = async (to: string, subject: string, html?:string, text?: string) => {\n  await transporter.sendMail({\n    from: process.env.SMTP_USER,\n    to,\n    subject,\n    html,\n    text,\n  });\n  return\n}\n","// src/emailService/sendVerifcationEmail.ts\n\n'use server'\n\nimport { sendMail } from \"./mailer\";\nimport { emailOptions } from \"../utils/options\";\n\nexport const sendVerificationEmail = async (to: string, code: number) => {\n    const { html, subject } = emailOptions();\n    const emailHtml = html.replace(/{{code}}/g, code.toString());\n    await sendMail(to, subject, emailHtml);\n    return\n}","// src/auth/register.ts\n\n'use server'\n\nimport { connectToDatabase } from \"../db/mongodb\";\nimport bcrypt from \"bcryptjs\";\nimport { generateVerificationCode } from \"../utils/otp\";\nimport { userSchemaOptions, authOptions } from \"../utils/options\";\nimport { sendVerificationEmail } from \"../emailService/sendVerifcationEmail\";\nimport { generateToken } from \"../utils/generateToken\";\nimport { getClientIp } from \"../utils/getClientIp\";\n\nexport async function registerUser(email: string, password: string) {\n    try {\n        const db = await connectToDatabase();\n    const users = db.collection(\"users\");\n\n    const existingUser = await users.findOne({ email});\n\n    if (existingUser) {\n        throw new Error(\"User already exists.\");\n    }\n\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const newUser = {\n        ...userSchemaOptions(),\n        email,\n        password: hashedPassword,\n        }\n\n        const insertedUser = await users.insertOne(newUser)\n\n        if(authOptions().verifcationRequired){\n            const verificationCode = await generateVerificationCode(insertedUser.insertedId.toString(), \"verification\")\n            sendVerificationEmail(email, verificationCode)\n            return {success: true, message: \"User created. Verification email sent.\", user: newUser}\n        }\n\n        const ip = getClientIp()\n\n        const token = generateToken(insertedUser.insertedId.toString(), ip.toString())\n\n        return {success: true, message: \"User created.\", user: newUser, token: token.hashedUserId}\n        } catch (error: any) {\n            return {success: false, message: error.message, user: {}}\n        }\n\n  }\n","// src/auth/login.ts\n\n'use server'\n\nimport { connectToDatabase } from \"../db/mongodb\"\nimport bcrypt from \"bcryptjs\"\nimport { getClientIp } from \"../utils/getClientIp\"\nimport { generateToken } from \"../utils/generateToken\"\nimport { authOptions } from \"../utils/options\"\n\nexport async function loginUser(identifier: string, password: string) {\n    try {\n        const db = await connectToDatabase()\n        const users = db.collection(\"users\")\n        const options = authOptions()\n        const hashedPassword = await bcrypt.hash(password, 10)\n\n        let query = {}\n        if (options.authMethod === \"email\") {\n            query = { email: identifier }\n        } else if (options.authMethod === \"username\") {\n            query = { username: identifier }\n        } else if (options.authMethod === \"both\") {\n            query = { $or: [{ email: identifier }, { username: identifier }] }\n        }\n\n        const user = await users.findOne(query)\n\n        if (!user || !(await bcrypt.compare(hashedPassword, user.password))) {\n            throw new Error(\"Invalid credentials.\")\n        }\n\n        if (options.verifcationRequired && !user.verified) {\n            throw new Error(\"Email verification required.\")\n        }\n\n        const clientIp = getClientIp()\n        if(!clientIp) {\n            throw new Error(\"Could not get client IP.\")\n        }\n\n        const token = generateToken(user._id.toString(), clientIp.toString())\n        await users.updateOne({ _id: user._id }, { $set: { 'codes.token': token.token } })\n\n        return { success: true, message: \"User logged in.\", token: token.hashedUserId, user: user }\n\n    } catch (error: any) {\n        return {success: false, message: error.message, token: \"\"}\n    }\n}","// src/auth/verification.ts\n\n'use server'\n\nimport { connectToDatabase } from \"../db/mongodb\";\nimport { sendVerificationEmail } from \"../emailService/sendVerifcationEmail\";\nimport { generateVerificationCode } from \"../utils/otp\";\nimport bcrypt from \"bcryptjs\";\n\nexport const verifyEmail = async (email: string, verificationCode: number) => {\n    const db = await connectToDatabase();\n    const users = db.collection(\"users\");\n    const user = await users.findOne({ email})\n\n    if (!user || user.codes.verification !== verificationCode) {\n        throw new Error(\"User not found, or verification code does not match.\");\n    }\n\n    await users.updateOne(\n        {email},\n        {\n            $set: {\n                verified: true,\n                'codes.verification': null\n            }\n        }\n    )\n    return {success: true, message: \"Email verified.\"}\n}\n\nexport const resendVerificationEmail = async (email: string) => {\n    const db = await connectToDatabase();\n    const users = db.collection(\"users\");\n    const user = await users.findOne({ email})\n\n    if (!user){\n        throw new Error(\"User not found.\")\n    }\n\n    const verificationCode = await generateVerificationCode(user._id.toString(), \"verification\")\n    await sendVerificationEmail(email, verificationCode) \n\n    return {success: true, message: \"Verification email sent.\"}\n}\n\nexport const requestPasswordReset = async (email: string) => {\n    const db = await connectToDatabase();\n    const users = db.collection(\"users\");\n    const user = await users.findOne({ email})\n\n    if (!user){\n        throw new Error(\"User not found.\")\n    }\n\n    const resetCode = await generateVerificationCode(user._id.toString(), \"reset\")\n    await sendVerificationEmail(email, resetCode)\n\n    return {success: true, message: \"Password reset email sent.\"}\n}\n\nexport const resetPassword = async (email: string, resetCode: number, newPassword: string) => {\n    const db = await connectToDatabase();\n    const users = db.collection(\"users\");\n    const user = await users.findOne({ email})\n\n    if (!user || user.codes.reset !== resetCode) {\n        throw new Error(\"User not found, or reset code does not match.\")\n    }\n\n    const hashedPassword = await bcrypt.hash(newPassword, 10)\n    await users.updateOne(\n        {email},\n        {\n            $set: {\n                password: hashedPassword,\n                'codes.reset': null\n            }\n        }\n    )\n\n    return {success: true, message: \"Password reset.\", user: user}\n}"],"mappings":"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","names":["jwt","crypto","path","fs","import_mongodb","import_jsonwebtoken","JWT_SECRET","jwt","path","import_server","config","path","path","React","nodemailer","bcrypt","import_bcryptjs","bcrypt","import_bcryptjs","bcrypt"]}